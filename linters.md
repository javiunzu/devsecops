# Linters

## What are linters?

Linters are programs that read and analyze source-code files and identify flaws
on them. Usually those flaws are based on configurable rules. Depending on the
tool, these flaws will be referred as problems, violations, issues or any other
word that suggests that the findings are something that has to be corrected.

The name "linter" comes from a tool originally called "lint" that analyzed C
source-code.

Linters fall into the category of static source-code analysis. Nowadays there
are linters for nearly every programming language.

## How do linters work?

Linters parse text files according to a given set of rules. Although some come
with an initial set, all of them let you customize the rules in effect.
Usually this is made with a configuration file in the root directory of a
project.

Along with the rules, exceptions can be declared. These are commonly known as
`pragmas`. The name comes again from the C programming language. The compiler
directive of the same name (#pragma) often used to suppress or force certain
compiler errors. Pragmas are annotations within the source-code and as such,
they should be used sparsely; otherwise if the rules or the linter change, there
is a good possibility that a lot of files have to be edited to comply again.

When a piece of code violates a rule, and a pragma is not found, the linter will
then issue a warning or error indicating what is the problem with the code.
Decent linters will even suggest how to fix the problem. Then it's the choice of
the developer to either fix the code, add an exception or review the rules.

## Why should I use linters?

Short answer: to avoid problems.
Kind of problems:

- Security issues. Most linters recognize common pitfalls and caveats of the
  language that could lead to vulnerable code.
- Performance issues. Modern linters are equipped to recognize expressions that
  have been deemed to produce unefficient code.
- Coding style. Linters can be used to comply to coding style guides. Therefore
  enforcing the use of these in a team will make new code more consistent with
  the existing one (assuming that the existing code already follows the style
  guide, that is).

## How NOT to use linters

In general, the only wrong way to use linters is not configuring them and
sticking to the default set of rules.

The default rules are an educated guess on which rules **might** make sense.
But in the end they will certainly won't be a 100% fit for your project
specifics.

You might think on using *pragmas* but, as mentioned earlier, these are meant to
be exception to the rule, not the rule.

### A (bad) real life-example

I worked on a project for a certain web application. The backend was written in
Python using Django and the client wanted to use `pylint` to armonize the code
base. But here's the thing: the code had to comply to the default set of rules.

To achieve that the code had to be modified no matter what and exceptions will
come in the form of pragmas that had to be "negotiated" with the Product Owner.
Every member of the team did its best to try to discourage the client ... to no
avail. And it went like this.

The version of pylint we used had a line length limit of 80 characters. If you
ever programmed in python, you will agree this is not a sane default. Comments
had to be squeezed, names of functions, classes, and variables had to be
shortened and anything with more than two levels of indentation had to be thrown
into unnecessary functions. List comprehensions had to be unrolled into other
structures, and table-like lists where splitted in awkward ways.

Pylint, by default also complains about the amount of public methods an object
has, the number of attributes, how many of them are public, etc ...
We ended up adding pragmas on literally every Python file of the project.

The list of awkward rules goes on and the modifications had to be applied even
on the files generated by the framework. Yeah, those files you should not be
touching.

Not to mention that modifying the whole codebase while still being able to
deploy was a daunting task. In the end, the result was a code base that made
nobody happy.

## How to use linters

Create a new configuration file on the root folder of your project and try to go
with the most restrictive set of rules - this is probably different for every
tool. Run it on your project and see how good does your code do.
For each found issue evaluate whether it makes sense or not. If it makes sense,
modify your code, if not suppress that warning.

Once you are done working on the rules, integrate the linter on your workflow.
Nowadays every IDE provides integration with linters. If not, you can use your
own script or even better: set a pre-commit hook.

Push the config file into version control so that others can use it.

There is still one more thing to do. Right now the linter runs locally but you
can install it on your CI/CD tool and include it as part of the release process.

Congratulations! You have successfuly created one of many quality gates for your
project.

### A (probably) better example

Let's return to the example of pylint for a Django project. If we scan our
project with the default set of rules,  we are going to see a lot of messages
and the overall rating of the code is going to be poor:

```
$ pylint $(git ls-files '*.py')
************* Module manage
web/manage.py:11:8: C0415: Import outside toplevel (django.core.management.execute_from_command_line) (import-outside-toplevel)
************* Module ratings.apps
web/ratings/apps.py:1:0: C0114: Missing module docstring (missing-module-docstring)
web/ratings/apps.py:4:0: C0115: Missing class docstring (missing-class-docstring)
************* Module ratings.privacy
web/ratings/privacy.py:10:0: C0304: Final newline missing (missing-final-newline)
web/ratings/privacy.py:1:0: C0114: Missing module docstring (missing-module-docstring)
web/ratings/privacy.py:4:0: C0116: Missing function or method docstring (missing-function-docstring)
************* Module ratings.views
web/ratings/views.py:22:0: C0301: Line too long (108/100) (line-too-long)
web/ratings/views.py:1:0: C0114: Missing module docstring (missing-module-docstring)
web/ratings/views.py:8:0: C0116: Missing function or method docstring (missing-function-docstring)
web/ratings/views.py:9:17: E1101: Class 'Candidate' has no 'objects' member (no-member)
web/ratings/views.py:10:17: E1101: Class 'Category' has no 'objects' member (no-member)
web/ratings/views.py:16:20: E1101: Class 'Vote' has no 'objects' member (no-member)
web/ratings/views.py:20:17: E1101: Class 'Category' has no 'objects' member (no-member)
web/ratings/views.py:25:0: C0116: Missing function or method docstring (missing-function-docstring)
web/ratings/views.py:26:12: E1101: Class 'Candidate' has no 'objects' member (no-member)
web/ratings/views.py:27:17: E1101: Class 'Category' has no 'objects' member (no-member)
web/ratings/views.py:31:0: C0116: Missing function or method docstring (missing-function-docstring)
web/ratings/views.py:45:24: W0621: Redefining name 'vote' from outer scope (line 25) (redefined-outer-name)
web/ratings/views.py:35:20: E1101: Class 'Candidate' has no 'objects' member (no-member)
web/ratings/views.py:39:31: E1101: Class 'Category' has no 'objects' member (no-member)
web/ratings/views.py:40:28: E1101: Class 'Vote' has no 'objects' member (no-member)
web/ratings/views.py:4:0: C0411: third party import "from django.db.models import Avg, Sum" should be placed before "from .models import Candidate, Category, Vote" (wrong-import-order)
web/ratings/views.py:5:0: C0411: third party import "from django.conf import settings" should be placed before "from .models import Candidate, Category, Vote" (wrong-import-order)
************* Module ratings.migrations.0001_initial
web/ratings/migrations/0001_initial.py:19:0: C0301: Line too long (114/100) (line-too-long)
web/ratings/migrations/0001_initial.py:27:0: C0301: Line too long (114/100) (line-too-long)
web/ratings/migrations/0001_initial.py:35:0: C0301: Line too long (114/100) (line-too-long)
web/ratings/migrations/0001_initial.py:36:0: C0301: Line too long (165/100) (line-too-long)
web/ratings/migrations/0001_initial.py:37:0: C0301: Line too long (151/100) (line-too-long)
web/ratings/migrations/0001_initial.py:39:0: C0301: Line too long (118/100) (line-too-long)
web/ratings/migrations/0001_initial.py:40:0: C0301: Line too long (116/100) (line-too-long)
web/ratings/migrations/0001_initial.py:1:0: C0103: Module name "0001_initial" doesn't conform to snake_case naming style (invalid-name)
web/ratings/migrations/0001_initial.py:1:0: C0114: Missing module docstring (missing-module-docstring)
web/ratings/migrations/0001_initial.py:8:0: C0115: Missing class docstring (missing-class-docstring)
************* Module ratings.admin
web/ratings/admin.py:1:0: C0114: Missing module docstring (missing-module-docstring)
web/ratings/admin.py:5:0: C0115: Missing class docstring (missing-class-docstring)
************* Module ratings.urls
web/ratings/urls.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module ratings.tests
web/ratings/tests.py:1:0: C0114: Missing module docstring (missing-module-docstring)
web/ratings/tests.py:1:0: W0611: Unused TestCase imported from django.test (unused-import)
************* Module ratings.models
web/ratings/models.py:16:0: C0301: Line too long (131/100) (line-too-long)
web/ratings/models.py:1:0: C0114: Missing module docstring (missing-module-docstring)
web/ratings/models.py:5:0: C0115: Missing class docstring (missing-class-docstring)
web/ratings/models.py:10:0: C0115: Missing class docstring (missing-class-docstring)
web/ratings/models.py:15:0: C0115: Missing class docstring (missing-class-docstring)
************* Module web.settings
web/web/settings.py:25:8: R1719: The if expression can be replaced with 'bool(test)' (simplifiable-if-expression)
************* Module web.urls
web/web/urls.py:1:0: C0114: Missing module docstring (missing-module-docstring)

-----------------------------------
Your code has been rated at 3.57/10
```

As you can see, a lot of these messages have to do with peculiarities of Django
itself.

First of all we can
have pylint generate a configuration file on the project's root folder:

```bash
pylint --generate-rcfile > $PROJECT/.pylintrc
```

There are some files that are generated by Django, and as such it is not our
concern if they follow style guides. You can skip some of them like so:

```
[MASTER]
...
ignore=manage.py, settings.py
ignore-paths=.*/migrations/.*
```

For dynamically generated attributes - like the objects of a query - you can add
this:

```
[TYPECHECK]
...
generated-members=objects
```

The line length in later versions is 100, but we can increase it to 120. A value
that has been adopted as a default from various specialized IDEs, like PyCharm.

```
[FORMAT]
...
max-line-length=120
```

The more we refine the rules to suit our needs, the more meaningful the issues
are. By editing the pylint configuration files we weeded out what otherwise
would have been annoying false positives.
Now we have a reasonable number of issues to address. Configuring a linter for
the first time certainly takes some time (this example took me a couple of
hours), but once it is done, the whole team can profit from it.
